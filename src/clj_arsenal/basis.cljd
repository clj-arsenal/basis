(ns clj-arsenal.basis
  (:require
   [cljd.core :refer [IFn]]
   ["dart:async" :as async]
   ["dart:core" :as dart]))

(defn try-fn
  [f & {catch-fn ::catch finally-fn ::finally}]
  (try
    (f)
    (catch Exception ex
      (when (ifn? catch-fn)
        (catch-fn ex)))
    (finally
      (when (ifn? finally-fn)
        (finally-fn)))))

(defn error?
  [x]
  (instance? Exception x))

(deftype ^:private Signal [!listeners]
  IFn
  (-invoke
    [this]
    (doseq [listener (vals @!listeners)]
      (listener))))

(defn signal
  []
  (->Signal (atom {})))

(defn sig-listen
  ([^Signal sig f]
   (sig-listen sig f f))
  ([^Signal sig k f]
   (swap! (.-!listeners sig) assoc k f)))

(defn sig-unlisten
  [^Signal sig k]
  (swap! (.-!listeners sig) dissoc k))

(defn schedule-once
  ^async/Timer [delay f & args]
  (async/Timer (dart/Duration .milliseconds delay) (fn [] (apply f args))))

(defn schedule-every
  ^async/Timer [delay f & args]
  (async/Timer.periodic (dart/Duration .milliseconds delay) (fn [^async/Timer _] (apply f args))))

(defn cancel-scheduled
  [^async/Timer t]
  (.cancel t))

(defn ticker
  [delay]
  (let [sig (signal)
        t (schedule-every delay sig)]
    [sig #(cancel-scheduled t)]))
