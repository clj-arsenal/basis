(ns clj-arsenal.basis
  (:require
   [cljd.core :refer [IFn IExceptionInfo ExceptionInfo]]
   ["dart:async" :as async]
   ["dart:core" :as dart]))

(deftype ExceptionWithTrace [cause stackTrace]
  Exception

  Object
  (toString
    [x]
    (.toString cause)))

(defn try-fn
  [f & {catch-fn :catch finally-fn :finally}]
  (try
    (f)
    (catch Error ex
      (when (ifn? catch-fn)
        (catch-fn ex)))
    (catch dynamic ex st
      (when (ifn? catch-fn)
        (catch-fn
          (if (satisfies? IExceptionInfo ex)
            (ex-info (if (instance? ExceptionInfo ex) (.-message ^ExceptionInfo ex) (str ex)) (assoc (ex-data ex) :st st) ex)
            (ex-info (str ex) {:st st} ex)))))
    (finally
      (when (ifn? finally-fn)
        (finally-fn)))))

(defn error?
  [x]
  (or (instance? Exception x) (instance? Error x) (satisfies? IExceptionInfo x)))

(deftype ^:private Signal [!listeners]
  IFn
  (-invoke
    [this]
    (doseq [listener (vals @!listeners)]
      (listener)))
  (-apply
    [this args]
    (this)))

(defn signal
  []
  (->Signal (atom {})))

(defn signal?
  [x]
  (instance? Signal x))

(defn sig-listen
  ([^Signal sig f]
   (sig-listen sig f f))
  ([^Signal sig k f]
   (swap! (.-!listeners sig) assoc k f)))

(defn sig-unlisten
  [^Signal sig k]
  (swap! (.-!listeners sig) dissoc k))

(defn schedule-once
  ^async/Timer [delay f & args]
  (async/Timer (dart/Duration .milliseconds delay) (fn [] (apply f args))))

(defn schedule-every
  ^async/Timer [delay f & args]
  (async/Timer.periodic (dart/Duration .milliseconds delay) (fn [^async/Timer _] (apply f args))))

(defn cancel-scheduled
  [^async/Timer t]
  (.cancel t))

(defn ticker
  [delay]
  (let [sig (signal)
        t (schedule-every delay sig)]
    [sig #(cancel-scheduled t)]))
